import { $ZodRegistry, toJSONSchema, $ZodType } from "zod/v4/core";
const getSchemaId = (id, io) => {
  return io === "input" ? `${id}Input` : id;
};
const getReferenceUri = (id, io) => {
  return `#/components/schemas/${getSchemaId(id, io)}`;
};
function isZodDate(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "date";
}
function isZodUnion(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "union";
}
function isZodUndefined(entity) {
  return entity instanceof $ZodType && entity._zod.def.type === "undefined";
}
const getOverride = (ctx, io) => {
  if (isZodUnion(ctx.zodSchema)) {
    ctx.jsonSchema.anyOf = ctx.jsonSchema.anyOf?.filter((schema) => Object.keys(schema).length > 0);
  }
  if (isZodDate(ctx.zodSchema)) {
    if (io === "output") {
      ctx.jsonSchema.type = "string";
      ctx.jsonSchema.format = "date-time";
    }
  }
  if (isZodUndefined(ctx.zodSchema)) {
    if (io === "output") {
      ctx.jsonSchema.type = "null";
    }
  }
};
const zodSchemaToJson = (zodSchema, registry, io, oasVersion, config = {}) => {
  const defaultTarget = oasVersion === "3.0" ? "openapi-3.0" : "draft-2020-12";
  const target = config?.target ?? defaultTarget;
  const schemaRegistryEntry = registry.get(zodSchema);
  if (schemaRegistryEntry?.id) {
    return {
      $ref: getReferenceUri(schemaRegistryEntry.id, io)
    };
  }
  const tempID = "GEN";
  const tempRegistry = new $ZodRegistry();
  tempRegistry.add(zodSchema, { id: tempID });
  const {
    schemas: { [tempID]: result }
  } = toJSONSchema(tempRegistry, {
    target,
    metadata: registry,
    io,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    /**
     * The uri option only allows customizing the base path of the `$ref`, and it automatically appends a path to it.
     * As a workaround, we set a placeholder that looks something like this:
     *
     * |       marker          | always added by zod | meta.id |
     * |__SCHEMA__PLACEHOLDER__|      #/$defs/       | User    |
     *
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/User"`
     * @example `__SCHEMA__PLACEHOLDER__#/$defs/Group"`
     *
     * @see jsonSchemaReplaceRef
     * @see https://github.com/colinhacks/zod/issues/4750
     */
    uri: () => `__SCHEMA__PLACEHOLDER__`,
    override: (ctx) => getOverride(ctx, io)
  });
  const jsonSchema = { ...result };
  delete jsonSchema.id;
  const normalizeId = (raw) => raw.replace(/^#\/(?:\$defs|definitions|components\/schemas)\//, "");
  const jsonSchemaReplaceRef = JSON.stringify(jsonSchema).replaceAll(
    /"__SCHEMA__PLACEHOLDER__(?:(?:#\/(?:\$defs|definitions|components\/schemas)\/))?([^"]+)"/g,
    (_, raw) => {
      const id = normalizeId(raw);
      return `"${getReferenceUri(id, io)}"`;
    }
  );
  return JSON.parse(jsonSchemaReplaceRef);
};
const zodRegistryToJson = (registry, io, config = {}) => {
  const { target = "draft-2020-12" } = config;
  const result = toJSONSchema(registry, {
    target,
    io,
    unrepresentable: "any",
    cycles: "ref",
    reused: "inline",
    uri: (id) => getReferenceUri(id, io),
    override: (ctx) => getOverride(ctx, io)
  }).schemas;
  const jsonSchemas = {};
  for (const id in result) {
    const jsonSchema = { ...result[id] };
    delete jsonSchema.id;
    jsonSchemas[getSchemaId(id, io)] = jsonSchema;
  }
  return jsonSchemas;
};
export {
  zodRegistryToJson,
  zodSchemaToJson
};
//# sourceMappingURL=zod-to-json.js.map
