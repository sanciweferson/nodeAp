"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const core = require("zod/v4/core");
const errors = require("./errors.cjs");
const jsonToOas = require("./json-to-oas.cjs");
const zodToJson = require("./zod-to-json.cjs");
const defaultSkipList = [
  "/documentation/",
  "/documentation/initOAuth",
  "/documentation/json",
  "/documentation/uiConfig",
  "/documentation/yaml",
  "/documentation/*",
  "/documentation/static/*"
];
const createJsonSchemaTransform = ({
  skipList = defaultSkipList,
  schemaRegistry = core.globalRegistry,
  zodToJsonConfig = {}
}) => {
  return (input) => {
    if ("swaggerObject" in input) {
      throw new Error("OpenAPI 2.0 is not supported");
    }
    const { schema, url } = input;
    if (!schema) {
      return {
        schema,
        url
      };
    }
    const { response, headers, querystring, body, params, hide, ...rest } = schema;
    const transformed = {};
    if (skipList.includes(url) || hide) {
      transformed.hide = true;
      return { schema: transformed, url };
    }
    const zodSchemas = { headers, querystring, body, params };
    const oasVersion = jsonToOas.getOASVersion(input);
    for (const prop in zodSchemas) {
      const zodSchema = zodSchemas[prop];
      if (zodSchema) {
        const jsonSchema = zodToJson.zodSchemaToJson(
          zodSchema,
          schemaRegistry,
          "input",
          oasVersion,
          zodToJsonConfig
        );
        const oasSchema = jsonToOas.jsonSchemaToOAS(jsonSchema, oasVersion);
        transformed[prop] = oasSchema;
      }
    }
    if (response) {
      transformed.response = {};
      for (const prop in response) {
        const zodSchema = resolveSchema(response[prop]);
        const jsonSchema = zodToJson.zodSchemaToJson(
          zodSchema,
          schemaRegistry,
          "output",
          oasVersion,
          zodToJsonConfig
        );
        if (jsonSchema.type === "null") {
          transformed.response[prop] = jsonSchema;
          continue;
        }
        const oasSchema = jsonToOas.jsonSchemaToOAS(jsonSchema, oasVersion);
        transformed.response[prop] = oasSchema;
      }
    }
    for (const prop in rest) {
      const meta = rest[prop];
      if (meta) {
        transformed[prop] = meta;
      }
    }
    return { schema: transformed, url };
  };
};
const jsonSchemaTransform = createJsonSchemaTransform({});
const createJsonSchemaTransformObject = ({
  schemaRegistry = core.globalRegistry,
  zodToJsonConfig = {}
}) => (input) => {
  if ("swaggerObject" in input) {
    throw new Error("OpenAPI 2.0 is not supported");
  }
  const oasVersion = jsonToOas.getOASVersion(input);
  const inputSchemas = zodToJson.zodRegistryToJson(schemaRegistry, "input", zodToJsonConfig);
  const outputSchemas = zodToJson.zodRegistryToJson(schemaRegistry, "output", zodToJsonConfig);
  for (const key in outputSchemas) {
    if (inputSchemas[key]) {
      throw new Error(
        `Collision detected for schema "${key}". The is already an input schema with the same name.`
      );
    }
  }
  const jsonSchemas = {
    ...inputSchemas,
    ...outputSchemas
  };
  const oasSchemas = Object.fromEntries(
    Object.entries(jsonSchemas).map(([key, value]) => [key, jsonToOas.jsonSchemaToOAS(value, oasVersion)])
  );
  return {
    ...input.openapiObject,
    components: {
      ...input.openapiObject.components,
      schemas: {
        ...input.openapiObject.components?.schemas,
        ...oasSchemas
      }
    }
  };
};
const jsonSchemaTransformObject = createJsonSchemaTransformObject({});
const validatorCompiler = ({ schema }) => (data) => {
  const result = core.safeParse(schema, data);
  if (result.error) {
    return { error: errors.createValidationError(result.error) };
  }
  return { value: result.data };
};
function resolveSchema(maybeSchema) {
  if (maybeSchema instanceof core.$ZodType) {
    return maybeSchema;
  }
  if ("properties" in maybeSchema && maybeSchema.properties instanceof core.$ZodType) {
    return maybeSchema.properties;
  }
  throw new errors.InvalidSchemaError(JSON.stringify(maybeSchema));
}
const createSerializerCompiler = (options) => ({ schema: maybeSchema, method, url }) => (data) => {
  const schema = resolveSchema(maybeSchema);
  const result = core.safeParse(schema, data);
  if (result.error) {
    throw new errors.ResponseSerializationError(method, url, {
      cause: result.error
    });
  }
  return JSON.stringify(result.data, options?.replacer);
};
const serializerCompiler = createSerializerCompiler({});
exports.createJsonSchemaTransform = createJsonSchemaTransform;
exports.createJsonSchemaTransformObject = createJsonSchemaTransformObject;
exports.createSerializerCompiler = createSerializerCompiler;
exports.jsonSchemaTransform = jsonSchemaTransform;
exports.jsonSchemaTransformObject = jsonSchemaTransformObject;
exports.serializerCompiler = serializerCompiler;
exports.validatorCompiler = validatorCompiler;
//# sourceMappingURL=core.cjs.map
