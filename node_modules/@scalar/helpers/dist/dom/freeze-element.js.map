{
  "version": 3,
  "sources": ["../../src/dom/freeze-element.ts"],
  "sourcesContent": ["/**\n * Scroll Freezing Utility\n * \"Freezes\" the scroll position of an element, so that it doesn't move when the rest of the content changes\n *\n * @example\n * const unfreeze = freezeElement(document.querySelector('#your-element'))\n * ... content changes ...\n * unfreeze()\n */\nexport const freezeElement = (element: HTMLElement) => {\n  if (!element) {\n    return () => null\n  }\n\n  // Get initial position relative to viewport\n  const rect = element.getBoundingClientRect()\n  const initialViewportTop = rect.top\n  let rafId: number | null = null\n\n  // Create mutation observer to watch for DOM changes\n  const observer = new MutationObserver((mutations) => {\n    // Only process if we have mutations that might affect layout\n    const shouldProcess = mutations.some(\n      (mutation) =>\n        mutation.type === 'childList' ||\n        (mutation.type === 'attributes' && (mutation.attributeName === 'style' || mutation.attributeName === 'class')),\n    )\n\n    if (!shouldProcess) {\n      return\n    }\n\n    // Cancel any pending animation frame\n    if (rafId !== null) {\n      cancelAnimationFrame(rafId)\n    }\n\n    // Schedule the scroll adjustment for the next frame\n    rafId = requestAnimationFrame(() => {\n      const newRect = element.getBoundingClientRect()\n      const currentViewportTop = newRect.top\n\n      // If element has moved from its initial viewport position\n      if (currentViewportTop !== initialViewportTop) {\n        // Calculate how far it moved\n        const diff = currentViewportTop - initialViewportTop\n        // Adjust scroll to maintain position\n        window.scrollBy(0, diff)\n      }\n      rafId = null\n    })\n  })\n\n  // Start observing with more specific configuration\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: ['style', 'class'],\n    characterData: false,\n  })\n\n  // Return function to stop maintaining position\n  return () => {\n    if (rafId !== null) {\n      cancelAnimationFrame(rafId)\n    }\n    observer.disconnect()\n  }\n}\n"],
  "mappings": "AASO,MAAM,gBAAgB,CAAC,YAAyB;AACrD,MAAI,CAAC,SAAS;AACZ,WAAO,MAAM;AAAA,EACf;AAGA,QAAM,OAAO,QAAQ,sBAAsB;AAC3C,QAAM,qBAAqB,KAAK;AAChC,MAAI,QAAuB;AAG3B,QAAM,WAAW,IAAI,iBAAiB,CAAC,cAAc;AAEnD,UAAM,gBAAgB,UAAU;AAAA,MAC9B,CAAC,aACC,SAAS,SAAS,eACjB,SAAS,SAAS,iBAAiB,SAAS,kBAAkB,WAAW,SAAS,kBAAkB;AAAA,IACzG;AAEA,QAAI,CAAC,eAAe;AAClB;AAAA,IACF;AAGA,QAAI,UAAU,MAAM;AAClB,2BAAqB,KAAK;AAAA,IAC5B;AAGA,YAAQ,sBAAsB,MAAM;AAClC,YAAM,UAAU,QAAQ,sBAAsB;AAC9C,YAAM,qBAAqB,QAAQ;AAGnC,UAAI,uBAAuB,oBAAoB;AAE7C,cAAM,OAAO,qBAAqB;AAElC,eAAO,SAAS,GAAG,IAAI;AAAA,MACzB;AACA,cAAQ;AAAA,IACV,CAAC;AAAA,EACH,CAAC;AAGD,WAAS,QAAQ,SAAS,MAAM;AAAA,IAC9B,WAAW;AAAA,IACX,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,iBAAiB,CAAC,SAAS,OAAO;AAAA,IAClC,eAAe;AAAA,EACjB,CAAC;AAGD,SAAO,MAAM;AACX,QAAI,UAAU,MAAM;AAClB,2BAAqB,KAAK;AAAA,IAC5B;AACA,aAAS,WAAW;AAAA,EACtB;AACF;",
  "names": []
}
