{
  "version": 3,
  "sources": ["../../../../src/utils/openapi/utils/workThroughQueue.ts"],
  "sourcesContent": ["import type { CommandChain, Merge, Queue, Task } from '@/types/index'\nimport { dereference } from '@/utils/dereference'\nimport { filter } from '@/utils/filter'\nimport { load } from '@/utils/load/load'\nimport { upgrade } from '@/utils/upgrade'\nimport { validate } from '@/utils/validate'\n\n/**\n * Takes a queue of tasks and works through them\n */\nexport async function workThroughQueue<T extends Task[]>(queue: Queue<T>): Promise<CommandChain<T>> {\n  const { input } = {\n    ...queue,\n  }\n  let result = {} as CommandChain<T>\n\n  // Work through the whole queue\n  for (const task of queue.tasks) {\n    const name: keyof Commands = task.name\n    const options: any = 'options' in task ? task.options : undefined\n\n    // Use the result of the previous task, or fall back to the original input\n    const currentSpecification = result.specification\n      ? result.specification\n      : typeof input === 'object'\n        ? // Detach from the original object\n          structuredClone(input)\n        : input\n\n    // load\n    if (name === 'load') {\n      result = {\n        ...result,\n        ...(await load(input, options as Commands['load']['task']['options'])),\n      } as Merge<typeof result, Awaited<typeof load>>\n    }\n\n    // validate\n    else if (name === 'filter') {\n      result = {\n        ...result,\n        ...filter(currentSpecification, options as Commands['filter']['task']['options']),\n      } as Merge<typeof result, ReturnType<typeof filter>>\n    }\n\n    // dereference\n    else if (name === 'dereference') {\n      result = {\n        ...result,\n        ...(await dereference(currentSpecification, options as Commands['dereference']['task']['options'])),\n      } as Merge<typeof result, Awaited<typeof dereference>>\n    }\n\n    // upgrade\n    else if (name === 'upgrade') {\n      result = {\n        ...result,\n        ...upgrade(currentSpecification),\n      } as Merge<typeof result, ReturnType<typeof upgrade>>\n    }\n\n    // validate\n    else if (name === 'validate') {\n      result = {\n        ...result,\n        ...(await validate(currentSpecification, options as Commands['validate']['task']['options'])),\n      } as Merge<typeof result, Awaited<typeof validate>>\n    }\n\n    // Make TS complain when we forgot to handle a command.\n    else {\n      const _: never = name\n\n      // @ts-expect-error Needed to allow the unused type to still be checked\n      const nada = _\n    }\n  }\n\n  return result\n}\n"],
  "mappings": "AACA,SAAS,mBAAmB;AAC5B,SAAS,cAAc;AACvB,SAAS,YAAY;AACrB,SAAS,eAAe;AACxB,SAAS,gBAAgB;AAKzB,eAAsB,iBAAmC,OAA2C;AAClG,QAAM,EAAE,MAAM,IAAI;AAAA,IAChB,GAAG;AAAA,EACL;AACA,MAAI,SAAS,CAAC;AAGd,aAAW,QAAQ,MAAM,OAAO;AAC9B,UAAM,OAAuB,KAAK;AAClC,UAAM,UAAe,aAAa,OAAO,KAAK,UAAU;AAGxD,UAAM,uBAAuB,OAAO,gBAChC,OAAO,gBACP,OAAO,UAAU;AAAA;AAAA,MAEf,gBAAgB,KAAK;AAAA,QACrB;AAGN,QAAI,SAAS,QAAQ;AACnB,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAI,MAAM,KAAK,OAAO,OAA8C;AAAA,MACtE;AAAA,IACF,WAGS,SAAS,UAAU;AAC1B,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAG,OAAO,sBAAsB,OAAgD;AAAA,MAClF;AAAA,IACF,WAGS,SAAS,eAAe;AAC/B,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAI,MAAM,YAAY,sBAAsB,OAAqD;AAAA,MACnG;AAAA,IACF,WAGS,SAAS,WAAW;AAC3B,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAG,QAAQ,oBAAoB;AAAA,MACjC;AAAA,IACF,WAGS,SAAS,YAAY;AAC5B,eAAS;AAAA,QACP,GAAG;AAAA,QACH,GAAI,MAAM,SAAS,sBAAsB,OAAkD;AAAA,MAC7F;AAAA,IACF,OAGK;AACH,YAAM,IAAW;AAGjB,YAAM,OAAO;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": []
}
