{
  "version": 3,
  "sources": ["../../../src/utils/load/load.ts"],
  "sourcesContent": ["import { ERRORS } from '@/configuration'\nimport type {\n  AnyApiDefinitionFormat,\n  AnyObject,\n  ErrorObject,\n  Filesystem,\n  LoadResult,\n  ThrowOnErrorOption,\n} from '@/types/index'\nimport { getEntrypoint } from '@/utils/get-entrypoint'\nimport { getListOfReferences } from '@/utils/get-list-of-references'\nimport { makeFilesystem } from '@/utils/make-filesystem'\nimport { normalize } from '@/utils/normalize'\n\nexport type LoadPlugin = {\n  check: (value?: any) => boolean\n  get: (value: any) => any\n  resolvePath?: (value: any, reference: string) => string\n  getDir?: (value: any) => string\n  getFilename?: (value: any) => string\n}\n\nexport type LoadOptions = {\n  plugins?: LoadPlugin[]\n  filename?: string\n  filesystem?: Filesystem\n} & ThrowOnErrorOption\n\n/**\n * @deprecated This function is deprecated and will be removed in a future version.\n * Please use the new bundler utility instead:\n * ```ts\n * import { bundle } from \"@scalar/openapi-parser\"\n * ```\n *\n * Loads an OpenAPI document, including any external references.\n *\n * This function handles loading content from various sources, normalizes the content,\n * and recursively loads any external references found within the definition.\n *\n * It builds a filesystem representation of all loaded content and collects any errors\n * encountered during the process.\n */\nexport async function load(value: AnyApiDefinitionFormat, options?: LoadOptions): Promise<LoadResult> {\n  const errors: ErrorObject[] = []\n\n  // Don't load a reference twice, check the filesystem before fetching something\n  if (options?.filesystem?.find((entry) => entry.filename === value)) {\n    return {\n      specification: getEntrypoint(options.filesystem)?.specification,\n      filesystem: options.filesystem,\n      errors,\n    }\n  }\n\n  // Check whether the value is an URL or file path\n  const plugin = options?.plugins?.find((thisPlugin) => thisPlugin.check(value))\n\n  let content: AnyObject\n\n  if (plugin) {\n    try {\n      content = normalize(await plugin.get(value))\n    } catch (_error) {\n      if (options?.throwOnError) {\n        throw new Error(ERRORS.EXTERNAL_REFERENCE_NOT_FOUND.replace('%s', value as string))\n      }\n\n      errors.push({\n        code: 'EXTERNAL_REFERENCE_NOT_FOUND',\n        message: ERRORS.EXTERNAL_REFERENCE_NOT_FOUND.replace('%s', value as string),\n      })\n\n      return {\n        specification: null,\n        filesystem: [],\n        errors,\n      }\n    }\n  } else {\n    content = normalize(value)\n  }\n\n  // No content\n  if (content === undefined) {\n    if (options?.throwOnError) {\n      throw new Error('No content to load')\n    }\n\n    errors.push({\n      code: 'NO_CONTENT',\n      message: ERRORS.NO_CONTENT,\n    })\n\n    return {\n      specification: null,\n      filesystem: [],\n      errors,\n    }\n  }\n\n  let filesystem = makeFilesystem(content, {\n    filename: options?.filename ?? null,\n  })\n\n  // Get references from file system entry, or from the content\n  const newEntry = options?.filename\n    ? filesystem.find((entry) => entry.filename === options?.filename)\n    : getEntrypoint(filesystem)\n\n  const listOfReferences = newEntry.references ?? getListOfReferences(content)\n\n  // No other references\n  if (listOfReferences.length === 0) {\n    return {\n      specification: getEntrypoint(filesystem)?.specification,\n      filesystem,\n      errors,\n    }\n  }\n\n  // Load other external references\n  for (const reference of listOfReferences) {\n    // Find a matching plugin\n    const otherPlugin = options?.plugins?.find((thisPlugin) => thisPlugin.check(reference))\n\n    // Skip if no plugin is found (internal references don't need a plugin for example)\n    if (!otherPlugin) {\n      continue\n    }\n\n    const target =\n      otherPlugin.check(reference) && otherPlugin.resolvePath ? otherPlugin.resolvePath(value, reference) : reference\n\n    // Don't load a reference twice, check the filesystem before fetching something\n    if (filesystem.find((entry) => entry.filename === reference)) {\n      continue\n    }\n\n    const { filesystem: referencedFiles, errors: newErrors } = await load(target, {\n      ...options,\n      // Make the filename the exact same value as the $ref\n      // TODO: This leads to problems, if there are multiple references with the same file name but in different folders\n      filename: reference,\n    })\n\n    errors.push(...newErrors)\n\n    filesystem = [\n      ...filesystem,\n      ...referencedFiles.map((file) => {\n        return {\n          ...file,\n          isEntrypoint: false,\n        }\n      }),\n    ]\n  }\n\n  return {\n    specification: getEntrypoint(filesystem)?.specification,\n    filesystem,\n    errors,\n  }\n}\n"],
  "mappings": "AAAA,SAAS,cAAc;AASvB,SAAS,qBAAqB;AAC9B,SAAS,2BAA2B;AACpC,SAAS,sBAAsB;AAC/B,SAAS,iBAAiB;AA+B1B,eAAsB,KAAK,OAA+B,SAA4C;AACpG,QAAM,SAAwB,CAAC;AAG/B,MAAI,SAAS,YAAY,KAAK,CAAC,UAAU,MAAM,aAAa,KAAK,GAAG;AAClE,WAAO;AAAA,MACL,eAAe,cAAc,QAAQ,UAAU,GAAG;AAAA,MAClD,YAAY,QAAQ;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAGA,QAAM,SAAS,SAAS,SAAS,KAAK,CAAC,eAAe,WAAW,MAAM,KAAK,CAAC;AAE7E,MAAI;AAEJ,MAAI,QAAQ;AACV,QAAI;AACF,gBAAU,UAAU,MAAM,OAAO,IAAI,KAAK,CAAC;AAAA,IAC7C,SAAS,QAAQ;AACf,UAAI,SAAS,cAAc;AACzB,cAAM,IAAI,MAAM,OAAO,6BAA6B,QAAQ,MAAM,KAAe,CAAC;AAAA,MACpF;AAEA,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,SAAS,OAAO,6BAA6B,QAAQ,MAAM,KAAe;AAAA,MAC5E,CAAC;AAED,aAAO;AAAA,QACL,eAAe;AAAA,QACf,YAAY,CAAC;AAAA,QACb;AAAA,MACF;AAAA,IACF;AAAA,EACF,OAAO;AACL,cAAU,UAAU,KAAK;AAAA,EAC3B;AAGA,MAAI,YAAY,QAAW;AACzB,QAAI,SAAS,cAAc;AACzB,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACtC;AAEA,WAAO,KAAK;AAAA,MACV,MAAM;AAAA,MACN,SAAS,OAAO;AAAA,IAClB,CAAC;AAED,WAAO;AAAA,MACL,eAAe;AAAA,MACf,YAAY,CAAC;AAAA,MACb;AAAA,IACF;AAAA,EACF;AAEA,MAAI,aAAa,eAAe,SAAS;AAAA,IACvC,UAAU,SAAS,YAAY;AAAA,EACjC,CAAC;AAGD,QAAM,WAAW,SAAS,WACtB,WAAW,KAAK,CAAC,UAAU,MAAM,aAAa,SAAS,QAAQ,IAC/D,cAAc,UAAU;AAE5B,QAAM,mBAAmB,SAAS,cAAc,oBAAoB,OAAO;AAG3E,MAAI,iBAAiB,WAAW,GAAG;AACjC,WAAO;AAAA,MACL,eAAe,cAAc,UAAU,GAAG;AAAA,MAC1C;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,aAAW,aAAa,kBAAkB;AAExC,UAAM,cAAc,SAAS,SAAS,KAAK,CAAC,eAAe,WAAW,MAAM,SAAS,CAAC;AAGtF,QAAI,CAAC,aAAa;AAChB;AAAA,IACF;AAEA,UAAM,SACJ,YAAY,MAAM,SAAS,KAAK,YAAY,cAAc,YAAY,YAAY,OAAO,SAAS,IAAI;AAGxG,QAAI,WAAW,KAAK,CAAC,UAAU,MAAM,aAAa,SAAS,GAAG;AAC5D;AAAA,IACF;AAEA,UAAM,EAAE,YAAY,iBAAiB,QAAQ,UAAU,IAAI,MAAM,KAAK,QAAQ;AAAA,MAC5E,GAAG;AAAA;AAAA;AAAA,MAGH,UAAU;AAAA,IACZ,CAAC;AAED,WAAO,KAAK,GAAG,SAAS;AAExB,iBAAa;AAAA,MACX,GAAG;AAAA,MACH,GAAG,gBAAgB,IAAI,CAAC,SAAS;AAC/B,eAAO;AAAA,UACL,GAAG;AAAA,UACH,cAAc;AAAA,QAChB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AAAA,IACL,eAAe,cAAc,UAAU,GAAG;AAAA,IAC1C;AAAA,IACA;AAAA,EACF;AACF;",
  "names": []
}
