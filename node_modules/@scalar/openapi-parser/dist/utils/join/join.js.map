{
  "version": 3,
  "sources": ["../../../src/utils/join/join.ts"],
  "sourcesContent": ["import type { UnknownObject } from '@/types'\nimport { mergeObjects } from '@/utils/join/merge-objects'\nimport { upgrade } from '@/utils/upgrade'\nimport { bundle } from '@scalar/json-magic/bundle'\nimport type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\n/**\n * Returns the intersection of two sets as an array.\n *\n * @param a - The first set\n * @param b - The second set\n * @returns An array containing the elements present in both sets\n *\n * @example\n * const setA = new Set([1, 2, 3, 4])\n * const setB = new Set([3, 4, 5, 6])\n * const intersection = getSetIntersection(setA, setB)\n * // intersection: [3, 4]\n */\nconst getSetIntersection = <T>(a: Set<T>, b: Set<T>): T[] => {\n  const result: T[] = []\n  for (const value of a) {\n    if (b.has(value)) {\n      result.push(value)\n    }\n  }\n  return result\n}\n\n/**\n * Returns the value if it is not nullish (or, for arrays, not empty), otherwise returns the provided default value.\n * Useful for handling OpenAPI fields that may be missing or empty.\n */\nconst withDefault = <T, K>(value: T, defaultValue: K): T | K => {\n  if (Array.isArray(value)) {\n    return value.length ? value : defaultValue\n  }\n\n  if (typeof value === 'object' && value !== null) {\n    return Object.keys(value).length ? value : defaultValue\n  }\n\n  return value ?? defaultValue\n}\n\n/**\n * Merges multiple OpenAPI PathsObjects into a single PathsObject.\n * - If a path does not exist in the result, it is added directly.\n * - If a path already exists, its operations (get, post, etc.) are merged.\n * - If the same operation (e.g., \"get\") exists for the same path in multiple inputs,\n *   a conflict is recorded for that path and method.\n *\n * @param inputs - Array of OpenAPIV3_1.PathsObject to merge\n * @returns An object containing the merged paths and a list of conflicts\n */\nconst mergePaths = (inputs: OpenAPIV3_1.PathsObject[]) => {\n  const result: OpenAPIV3_1.PathsObject = {}\n  const conflicts: { path: string; method: string }[] = []\n\n  for (const paths of inputs) {\n    if (typeof paths !== 'object') {\n      continue\n    }\n\n    for (const [path, pathItem] of Object.entries(paths)) {\n      if (!result[path]) {\n        // If the path does not exist, add it directly\n        result[path] = pathItem\n        continue\n      }\n\n      // Find intersecting operation keys (e.g., \"get\", \"post\") for this path\n      const intersectingKeys = getSetIntersection(new Set(Object.keys(result[path])), new Set(Object.keys(pathItem)))\n\n      // If the path exists, merge the operations (get, post, etc.)\n      result[path] = { ...result[path], ...pathItem }\n      // Record conflicts for each intersecting operation key\n      intersectingKeys.forEach((key) => conflicts.push({ method: key, path }))\n    }\n  }\n\n  return { paths: result, conflicts }\n}\n\n/**\n * Merges multiple arrays of OpenAPI TagObjects into a single array, ensuring uniqueness by tag name.\n * - If a tag with the same name appears in multiple arrays, only the first occurrence is included in the result.\n *\n * @param inputs - Array of arrays of OpenAPIV3_1.TagObject to merge\n * @returns An array of unique TagObjects (by name)\n */\nconst mergeTags = (inputs: OpenAPIV3_1.TagObject[][]) => {\n  const cache = new Set<string>()\n  const result: OpenAPIV3_1.TagObject[] = []\n\n  for (const tags of inputs) {\n    for (const tag of tags) {\n      if (!cache.has(tag.name)) {\n        result.push(tag)\n      }\n      cache.add(tag.name)\n    }\n  }\n\n  return result\n}\n\n/**\n * Merges multiple arrays of OpenAPI ServerObjects into a single array, ensuring uniqueness by server URL.\n * - If a server with the same URL appears in multiple arrays, only the first occurrence is included in the result.\n *\n * @param inputs - Array of arrays of OpenAPIV3_1.ServerObject to merge\n * @returns An array of unique ServerObjects (by url)\n */\nconst mergeServers = (inputs: OpenAPIV3_1.ServerObject[][]) => {\n  const cache = new Set<string>()\n  const result: OpenAPIV3_1.ServerObject[] = []\n\n  for (const servers of inputs) {\n    for (const server of servers) {\n      if (!cache.has(server.url)) {\n        result.push(server)\n      }\n      cache.add(server.url)\n    }\n  }\n\n  return result\n}\n\n/**\n * Merges multiple OpenAPI ComponentsObject instances into a single components object.\n * - If a component with the same type and name appears in multiple inputs, only the first occurrence is included.\n * - Any conflicts (duplicate component names within the same type) are recorded in the `conflicts` array.\n *\n * @param inputs - Array of OpenAPIV3_1.ComponentsObject to merge\n * @returns An object containing the merged components and an array of conflicts\n */\nconst mergeComponents = (inputs: OpenAPIV3_1.ComponentsObject[]) => {\n  const result: OpenAPIV3_1.ComponentsObject = {}\n  const conflicts: { componentType: string; name: string }[] = []\n\n  for (const components of inputs) {\n    if (typeof components !== 'object') {\n      continue\n    }\n\n    // Merge each component type (schemas, responses, parameters, etc.)\n    for (const [key, value] of Object.entries(components)) {\n      for (const [name, component] of Object.entries(value)) {\n        if (!result[key]) {\n          result[key] = {}\n        }\n\n        if (result[key][name]) {\n          // If the component already exists, record a conflict\n          conflicts.push({ componentType: key, name })\n        } else {\n          // Otherwise, add the component\n          result[key][name] = component\n        }\n      }\n    }\n  }\n\n  return { components: result, conflicts }\n}\n\n/**\n * Prefixes component names and their references in multiple OpenAPI documents.\n *\n * This function mutates each input document in-place by:\n *   1. Prefixing all component names (e.g., schema names) with the corresponding prefix.\n *   2. Updating all $ref values that point to components to use the prefixed names.\n *\n * This is useful when merging multiple OpenAPI documents to avoid component name collisions.\n *\n * @param inputs - Array of OpenAPI documents to mutate.\n * @param prefixes - Array of prefixes to apply to each document's components.\n */\nconst prefixComponents = async (inputs: OpenAPIV3_1.Document[], prefixes: string[]) => {\n  for (const index of inputs.keys()) {\n    await bundle(inputs[index], {\n      treeShake: false,\n      urlMap: false,\n      plugins: [\n        // Plugin to update $ref values to use the prefixed component names\n        {\n          type: 'lifecycle',\n          onBeforeNodeProcess: (node) => {\n            const ref = node['$ref']\n\n            if (typeof ref !== 'string') {\n              return\n            }\n\n            // Only process refs that point to components\n            if (!ref.startsWith('#/components/')) {\n              return\n            }\n\n            const parts = ref.split('/')\n            // Ensure the ref has the expected structure: #/components/{type}/{name}\n            if (parts.length < 4) {\n              return\n            }\n\n            // Prefix the component name (parts[3]) with the provided prefix\n            parts[3] = `${prefixes[index] ?? ''}${parts[3]}`\n\n            node['$ref'] = parts.join('/')\n          },\n        },\n        // Plugin to rename component keys with the prefix\n        {\n          type: 'lifecycle',\n          onBeforeNodeProcess: (node, context) => {\n            // Check if the node is a component type object (e.g., schemas, responses) under \"components\"\n            if (context.path.length === 2 && context.path[0] === 'components') {\n              const prefix = prefixes[index]\n\n              Object.keys(node).forEach((key) => {\n                const newKey = `${prefix ?? ''}${key}`\n                const childNode = node[key]\n                delete node[key]\n                node[newKey] = childNode\n              })\n            }\n          },\n        },\n      ],\n    })\n  }\n}\n\nexport type Conflicts =\n  | { type: 'path'; path: string; method: string }\n  | { type: 'webhook'; path: string; method: string }\n  | { type: 'component'; componentType: string; name: string }\ntype JoinResult = { ok: true; document: OpenAPIV3_1.Document } | { ok: false; conflicts: Conflicts[] }\n\n/**\n * Joins multiple OpenAPI documents into a single document.\n *\n * - Merges the \"info\" object, paths, webhooks, tags, and servers from all input documents.\n * - If there are conflicting paths or webhooks (same path and method), returns a list of conflicts.\n * - Only the first occurrence of a tag (by name) or server (by url) is included.\n * - The merge is performed in reverse order, so the first document in the input array has the highest precedence.\n *\n * @param inputs - Array of OpenAPI documents (UnknownObject) to join\n * @returns {JoinResult} - { ok: true, document } if successful, or { ok: false, conflicts } if there are conflicts\n *\n * @example\n * const doc1 = {\n *   info: { title: \"API 1\", version: \"1.0.0\" },\n *   paths: { \"/foo\": { get: { summary: \"Get Foo\" } } },\n *   tags: [{ name: \"foo\" }],\n *   servers: [{ url: \"https://api1.example.com\" }]\n * }\n * const doc2 = {\n *   info: { description: \"Second API\" },\n *   paths: { \"/bar\": { get: { summary: \"Get Bar\" } } },\n *   tags: [{ name: \"bar\" }],\n *   servers: [{ url: \"https://api2.example.com\" }]\n * }\n * const result = join([doc1, doc2])\n * // result.ok === true\n * // result.document.info.title === \"API 1\"\n * // result.document.info.description === \"Second API\"\n * // result.document.paths has both \"/foo\" and \"/bar\"\n * // result.document.tags contains both \"foo\" and \"bar\"\n * // result.document.servers contains both server URLs\n */\nexport const join = async (inputs: UnknownObject[], config?: { prefixComponents: string[] }): Promise<JoinResult> => {\n  // Reverse the input list and upgrade them (first input has highest precedence)\n  const upgraded = inputs.map((it) => upgrade(it).specification)\n\n  // Preprocess documents by prefixing components if specified\n  if (config?.prefixComponents) {\n    await prefixComponents(upgraded, config.prefixComponents)\n  }\n\n  // Reverse the upgraded documents to ensure the first document has the highest precedence\n  upgraded.reverse()\n\n  // Merge only the \"info\" object from all inputs\n  const info = upgraded.reduce<OpenAPIV3_1.InfoObject>((acc, curr) => {\n    if (curr.info && typeof curr.info === 'object') {\n      return mergeObjects(acc, curr.info)\n    }\n    return acc\n  }, {} as OpenAPIV3_1.InfoObject)\n\n  // Merge paths from all documents, collecting conflicts\n  const { paths, conflicts: pathConflicts } = mergePaths(upgraded.map((it) => it.paths ?? {}))\n\n  // Merge webhooks from all documents, collecting conflicts\n  const { paths: webhooks, conflicts: webhookConflicts } = mergePaths(upgraded.map((it) => it.webhooks ?? {}))\n\n  // Merge tags, ensuring uniqueness by tag name\n  const tags = mergeTags(upgraded.map((it) => it.tags ?? []))\n\n  // Merge servers, ensuring uniqueness by server url\n  const servers = mergeServers(upgraded.map((it) => it.servers ?? []))\n\n  // Merge components, collecting conflicts\n  const { components, conflicts: componentConflicts } = mergeComponents(upgraded.map((it) => it.components ?? {}))\n\n  // Merge all documents in the upgraded array into a single object (shallow merge)\n  const result = upgraded.reduce<UnknownObject>((acc, curr) => ({ ...acc, ...curr }), {})\n\n  // Collect all conflicts (paths and webhooks)\n  const conflicts: Conflicts[] = [\n    ...pathConflicts.map((it) => ({ type: 'path', ...it }) as const),\n    ...webhookConflicts.map((it) => ({ type: 'webhook', ...it }) as const),\n    ...componentConflicts.map((it) => ({ type: 'component', ...it }) as const),\n  ]\n\n  // If there are any conflicts, return them\n  if (conflicts.length) {\n    return {\n      ok: false,\n      conflicts,\n    }\n  }\n\n  // Return the merged OpenAPI document\n  return {\n    ok: true,\n    document: {\n      ...result,\n      info,\n      paths,\n      webhooks: withDefault(webhooks, undefined),\n      tags: withDefault(tags, undefined),\n      servers: withDefault(servers, undefined),\n      components: withDefault(components, undefined),\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
