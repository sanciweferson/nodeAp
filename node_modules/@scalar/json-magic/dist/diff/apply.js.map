{
  "version": 3,
  "sources": ["../../src/diff/apply.ts"],
  "sourcesContent": ["import type { Difference } from '@/diff/diff'\n\nexport class InvalidChangesDetectedError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'InvalidChangesDetectedError'\n  }\n}\n\n/**\n * Applies a set of differences to a document object.\n * The function traverses the document structure following the paths specified in the differences\n * and applies the corresponding changes (add, update, or delete) at each location.\n *\n * @param document - The original document to apply changes to\n * @param diff - Array of differences to apply, each containing a path and change type\n * @returns The modified document with all changes applied\n *\n * @example\n * const original = {\n *   paths: {\n *     '/users': {\n *       get: { responses: { '200': { description: 'OK' } } }\n *     }\n *   }\n * }\n *\n * const changes = [\n *   {\n *     path: ['paths', '/users', 'get', 'responses', '200', 'content'],\n *     type: 'add',\n *     changes: { 'application/json': { schema: { type: 'object' } } }\n *   }\n * ]\n *\n * const updated = apply(original, changes)\n * // Result: original document with content added to the 200 response\n */\nexport const apply = <T extends Record<string, unknown>>(\n  document: Record<string, unknown>,\n  diff: Difference<T>[],\n): T => {\n  // Traverse the object and apply the change\n  const applyChange = (current: any, path: string[], d: Difference<T>, depth = 0) => {\n    if (path[depth] === undefined) {\n      throw new InvalidChangesDetectedError(\n        `Process aborted. Path ${path.join('.')} at depth ${depth} is undefined, check diff object`,\n      )\n    }\n\n    // We reach where we want to be, now we can apply changes\n    if (depth >= path.length - 1) {\n      if (d.type === 'add' || d.type === 'update') {\n        current[path[depth]] = d.changes\n      } else {\n        // For arrays we don't use delete operator since it will leave blank spots and not actually remove the element\n        if (Array.isArray(current)) {\n          current.splice(Number.parseInt(path[depth]), 1)\n        } else {\n          delete current[path[depth]]\n        }\n      }\n      return\n    }\n\n    // Throw an error\n    // This scenario should not happen\n    // 1- if we are adding a new entry, the diff should only give us the higher level diff\n    // 2- if we are updating/deleting an entry, the path to that entry should exists\n    if (current[path[depth]] === undefined || typeof current[path[depth]] !== 'object') {\n      throw new InvalidChangesDetectedError('Process aborted, check diff object')\n    }\n    applyChange(current[path[depth]], path, d, depth + 1)\n  }\n\n  for (const d of diff) {\n    applyChange(document, d.path, d)\n  }\n\n  // It is safe to cast here because this function mutates the input document\n  // to match the target type T as described by the diff changeset.\n  return document as T\n}\n"],
  "mappings": "AAEO,MAAM,oCAAoC,MAAM;AAAA,EACrD,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AA+BO,MAAM,QAAQ,CACnB,UACA,SACM;AAEN,QAAM,cAAc,CAAC,SAAc,MAAgB,GAAkB,QAAQ,MAAM;AACjF,QAAI,KAAK,KAAK,MAAM,QAAW;AAC7B,YAAM,IAAI;AAAA,QACR,yBAAyB,KAAK,KAAK,GAAG,CAAC,aAAa,KAAK;AAAA,MAC3D;AAAA,IACF;AAGA,QAAI,SAAS,KAAK,SAAS,GAAG;AAC5B,UAAI,EAAE,SAAS,SAAS,EAAE,SAAS,UAAU;AAC3C,gBAAQ,KAAK,KAAK,CAAC,IAAI,EAAE;AAAA,MAC3B,OAAO;AAEL,YAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,kBAAQ,OAAO,OAAO,SAAS,KAAK,KAAK,CAAC,GAAG,CAAC;AAAA,QAChD,OAAO;AACL,iBAAO,QAAQ,KAAK,KAAK,CAAC;AAAA,QAC5B;AAAA,MACF;AACA;AAAA,IACF;AAMA,QAAI,QAAQ,KAAK,KAAK,CAAC,MAAM,UAAa,OAAO,QAAQ,KAAK,KAAK,CAAC,MAAM,UAAU;AAClF,YAAM,IAAI,4BAA4B,oCAAoC;AAAA,IAC5E;AACA,gBAAY,QAAQ,KAAK,KAAK,CAAC,GAAG,MAAM,GAAG,QAAQ,CAAC;AAAA,EACtD;AAEA,aAAW,KAAK,MAAM;AACpB,gBAAY,UAAU,EAAE,MAAM,CAAC;AAAA,EACjC;AAIA,SAAO;AACT;",
  "names": []
}
