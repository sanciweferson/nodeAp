import { escapeJsonPointer } from "../utils/escape-json-pointer.js";
import path from "../polyfills/path.js";
import { getSegmentsFromPath } from "../utils/get-segments-from-path.js";
import { isObject } from "../utils/is-object.js";
import { isYaml } from "../utils/is-yaml.js";
import { isJsonObject } from "../utils/is-json-object.js";
import { getHash, uniqueValueGeneratorFactory } from "./value-generator.js";
function isRemoteUrl(value) {
  try {
    const url = new URL(value);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}
function isFilePath(value) {
  return !isRemoteUrl(value) && !isYaml(value) && !isJsonObject(value);
}
function isLocalRef(value) {
  return value.startsWith("#");
}
async function resolveContents(value, plugins) {
  const plugin = plugins.find((p) => p.validate(value));
  if (plugin) {
    return plugin.exec(value);
  }
  return {
    ok: false
  };
}
function getNestedValue(target, segments) {
  return segments.reduce((acc, key) => {
    if (acc === void 0) {
      return void 0;
    }
    return acc[key];
  }, target);
}
function setValueAtPath(obj, path2, value) {
  if (path2 === "") {
    throw new Error("Cannot set value at root ('') pointer");
  }
  const parts = getSegmentsFromPath(path2);
  let current = obj;
  for (let i = 0; i < parts.length; i++) {
    const key = parts[i];
    const isLast = i === parts.length - 1;
    const nextKey = parts[i + 1];
    const shouldBeArray = /^\d+$/.test(nextKey ?? "");
    if (isLast) {
      current[key] = value;
    } else {
      if (!(key in current) || typeof current[key] !== "object") {
        current[key] = shouldBeArray ? [] : {};
      }
      current = current[key];
    }
  }
}
function resolveReferencePath(base, relativePath) {
  if (isRemoteUrl(relativePath)) {
    return relativePath;
  }
  if (isRemoteUrl(base)) {
    const url = new URL(base);
    if (relativePath.startsWith("/")) {
      url.pathname = relativePath;
      return url.toString();
    }
    const mergedPath = path.join(path.dirname(url.pathname), relativePath);
    return new URL(mergedPath, base).toString();
  }
  return path.join(path.dirname(base), relativePath);
}
function prefixInternalRef(input, prefix) {
  if (!isLocalRef(input)) {
    throw "Please provide an internal ref";
  }
  return `#/${prefix.map(escapeJsonPointer).join("/")}${input.substring(1)}`;
}
function prefixInternalRefRecursive(input, prefix) {
  if (!isObject(input)) {
    return;
  }
  Object.values(input).forEach((el) => prefixInternalRefRecursive(el, prefix));
  if (typeof input === "object" && "$ref" in input && typeof input["$ref"] === "string") {
    const ref = input["$ref"];
    if (!isLocalRef(ref)) {
      return;
    }
    input["$ref"] = prefixInternalRef(ref, prefix);
  }
}
const resolveAndCopyReferences = (targetDocument, sourceDocument, referencePath, externalRefsKey, documentKey, processedNodes = /* @__PURE__ */ new Set()) => {
  const referencedValue = getNestedValue(sourceDocument, getSegmentsFromPath(referencePath));
  if (processedNodes.has(referencedValue)) {
    return;
  }
  processedNodes.add(referencedValue);
  setValueAtPath(targetDocument, referencePath, referencedValue);
  const traverse = (node) => {
    if (!node || typeof node !== "object") {
      return;
    }
    if ("$ref" in node && typeof node["$ref"] === "string") {
      if (node["$ref"].startsWith(`#/${externalRefsKey}/${escapeJsonPointer(documentKey)}`)) {
        resolveAndCopyReferences(
          targetDocument,
          sourceDocument,
          node["$ref"].substring(1),
          documentKey,
          externalRefsKey,
          processedNodes
        );
      }
    }
    for (const value of Object.values(node)) {
      traverse(value);
    }
  };
  traverse(referencedValue);
};
const extensions = {
  /**
   * Custom OpenAPI extension key used to store external references.
   * This key will contain all bundled external documents.
   * The x-ext key is used to maintain a clean separation between the main
   * OpenAPI document and its bundled external references.
   */
  externalDocuments: "x-ext",
  /**
   * Custom OpenAPI extension key used to maintain a mapping between
   * hashed keys and their original URLs in x-ext.
   * This mapping is essential for tracking the source of bundled references
   */
  externalDocumentsMappings: "x-ext-urls"
};
async function bundle(input, config) {
  const cache = config.cache ?? /* @__PURE__ */ new Map();
  const loaderPlugins = config.plugins.filter((it) => it.type === "loader");
  const lifecyclePlugin = config.plugins.filter((it) => it.type === "lifecycle");
  const resolveInput = async () => {
    if (typeof input !== "string") {
      return input;
    }
    const result = await resolveContents(input, loaderPlugins);
    if (result.ok && typeof result.data === "object") {
      return result.data;
    }
    throw new Error(
      "Failed to resolve input: Please provide a valid string value or pass a loader to process the input"
    );
  };
  const rawSpecification = await resolveInput();
  const documentRoot = config.root ?? rawSpecification;
  const isPartialBundling = config.root !== void 0 && config.root !== rawSpecification || config.depth !== void 0;
  const processedNodes = config.visitedNodes ?? /* @__PURE__ */ new Set();
  const defaultOrigin = () => {
    if (config.origin) {
      return config.origin;
    }
    if (typeof input !== "string") {
      return "";
    }
    if (isRemoteUrl(input) || isFilePath(input)) {
      return input;
    }
    return "";
  };
  if (documentRoot[extensions.externalDocumentsMappings] === void 0) {
    documentRoot[extensions.externalDocumentsMappings] = {};
  }
  const { generate } = uniqueValueGeneratorFactory(
    config.compress ?? getHash,
    documentRoot[extensions.externalDocumentsMappings]
  );
  const bundler = async (root, origin = defaultOrigin(), isChunkParent = false, depth = 0, path2 = [], parent = null) => {
    if (config.depth !== void 0 && depth > config.depth) {
      return;
    }
    if (!isObject(root) && !Array.isArray(root)) {
      return;
    }
    if (processedNodes.has(root)) {
      return;
    }
    processedNodes.add(root);
    await config.hooks?.onBeforeNodeProcess?.(root, {
      path: path2,
      resolutionCache: cache,
      parentNode: parent,
      rootNode: documentRoot,
      loaders: loaderPlugins
    });
    for (const plugin of lifecyclePlugin) {
      await plugin.onBeforeNodeProcess?.(root, {
        path: path2,
        resolutionCache: cache,
        parentNode: parent,
        rootNode: documentRoot,
        loaders: loaderPlugins
      });
    }
    if (typeof root === "object" && "$ref" in root && typeof root["$ref"] === "string") {
      const ref = root["$ref"];
      const isChunk = "$global" in root && typeof root["$global"] === "boolean" && root["$global"];
      if (isLocalRef(ref)) {
        if (isPartialBundling) {
          const segments = getSegmentsFromPath(ref.substring(1));
          const parent2 = segments.length > 0 ? getNestedValue(documentRoot, segments.slice(0, -1)) : void 0;
          await bundler(getNestedValue(documentRoot, segments), origin, isChunkParent, depth + 1, segments, parent2);
        }
        return;
      }
      const [prefix, path3 = ""] = ref.split("#", 2);
      const resolvedPath = resolveReferencePath(origin, prefix);
      const compressedPath = await generate(resolvedPath);
      const seen = cache.has(resolvedPath);
      if (!seen) {
        cache.set(resolvedPath, resolveContents(resolvedPath, loaderPlugins));
      }
      config?.hooks?.onResolveStart?.(root);
      lifecyclePlugin.forEach((it) => it.onResolveStart?.(root));
      const result = await cache.get(resolvedPath);
      if (result.ok) {
        if (!seen) {
          if (!isChunk) {
            prefixInternalRefRecursive(result.data, [extensions.externalDocuments, compressedPath]);
          }
          await bundler(result.data, isChunk ? origin : resolvedPath, isChunk, depth + 1, [
            extensions.externalDocuments,
            compressedPath,
            documentRoot[extensions.externalDocumentsMappings]
          ]);
          setValueAtPath(
            documentRoot,
            `/${extensions.externalDocumentsMappings}/${escapeJsonPointer(compressedPath)}`,
            resolvedPath
          );
        }
        if (config.treeShake === true) {
          resolveAndCopyReferences(
            documentRoot,
            { [extensions.externalDocuments]: { [compressedPath]: result.data } },
            prefixInternalRef(`#${path3}`, [extensions.externalDocuments, compressedPath]).substring(1),
            extensions.externalDocuments,
            compressedPath
          );
        } else if (!seen) {
          setValueAtPath(documentRoot, `/${extensions.externalDocuments}/${compressedPath}`, result.data);
        }
        root.$ref = prefixInternalRef(`#${path3}`, [extensions.externalDocuments, compressedPath]);
        config?.hooks?.onResolveSuccess?.(root);
        lifecyclePlugin.forEach((it) => it.onResolveSuccess?.(root));
        return;
      }
      config?.hooks?.onResolveError?.(root);
      lifecyclePlugin.forEach((it) => it.onResolveError?.(root));
      return console.warn(
        `Failed to resolve external reference "${resolvedPath}". The reference may be invalid, inaccessible, or missing a loader for this type of reference.`
      );
    }
    await Promise.all(
      Object.entries(root).map(async ([key, value]) => {
        if (key === extensions.externalDocuments || key === extensions.externalDocumentsMappings) {
          return;
        }
        await bundler(value, origin, isChunkParent, depth + 1, [...path2, key], root);
      })
    );
    await config.hooks?.onAfterNodeProcess?.(root, {
      path: path2,
      resolutionCache: cache,
      parentNode: parent,
      rootNode: documentRoot,
      loaders: loaderPlugins
    });
    for (const plugin of lifecyclePlugin) {
      await plugin.onAfterNodeProcess?.(root, {
        path: path2,
        resolutionCache: cache,
        parentNode: parent,
        rootNode: documentRoot,
        loaders: loaderPlugins
      });
    }
  };
  await bundler(rawSpecification);
  if (!config.urlMap && !isPartialBundling) {
    delete documentRoot[extensions.externalDocumentsMappings];
  }
  return rawSpecification;
}
export {
  bundle,
  getNestedValue,
  isFilePath,
  isLocalRef,
  isRemoteUrl,
  prefixInternalRef,
  prefixInternalRefRecursive,
  setValueAtPath
};
//# sourceMappingURL=bundle.js.map
