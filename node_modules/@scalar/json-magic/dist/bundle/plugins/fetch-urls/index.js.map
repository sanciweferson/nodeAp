{
  "version": 3,
  "sources": ["../../../../src/bundle/plugins/fetch-urls/index.ts"],
  "sourcesContent": ["import { normalize } from '@/utils/normalize'\nimport { createLimiter } from '@/bundle/create-limiter'\nimport type { LoaderPlugin, ResolveResult } from '@/bundle'\nimport { isRemoteUrl } from '@/bundle/bundle'\n\ntype FetchConfig = Partial<{\n  headers: { headers: HeadersInit; domains: string[] }[]\n  fetch: (input: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response>\n}>\n\n/**\n * Safely checks for host from a URL\n * Needed because we cannot create a URL from a relative remote URL ex: examples/openapi.json\n */\nconst getHost = (url: string): string | null => {\n  try {\n    return new URL(url).host\n  } catch {\n    return null\n  }\n}\n\n/**\n * Fetches and normalizes data from a remote URL\n * @param url - The URL to fetch data from\n * @returns A promise that resolves to either the normalized data or an error result\n * @example\n * ```ts\n * const result = await fetchUrl('https://api.example.com/data.json')\n * if (result.ok) {\n *   console.log(result.data) // The normalized data\n * } else {\n *   console.log('Failed to fetch data')\n * }\n * ```\n */\nexport async function fetchUrl(\n  url: string,\n  limiter: <T>(fn: () => Promise<T>) => Promise<T>,\n  config?: FetchConfig,\n): Promise<ResolveResult> {\n  try {\n    const host = getHost(url)\n\n    // Get the headers that match the domain\n    const headers = config?.headers?.find((a) => a.domains.find((d) => d === host) !== undefined)?.headers\n\n    const exec = config?.fetch ?? fetch\n\n    const result = await limiter(() =>\n      exec(url, {\n        headers,\n      }),\n    )\n\n    if (result.ok) {\n      const body = await result.text()\n\n      return {\n        ok: true,\n        data: normalize(body),\n      }\n    }\n\n    return {\n      ok: false,\n    }\n  } catch {\n    return {\n      ok: false,\n    }\n  }\n}\n\n/**\n * Creates a plugin for handling remote URL references.\n * This plugin validates and fetches data from HTTP/HTTPS URLs.\n *\n * @returns A plugin object with validate and exec functions\n * @example\n * const urlPlugin = fetchUrls()\n * if (urlPlugin.validate('https://example.com/schema.json')) {\n *   const result = await urlPlugin.exec('https://example.com/schema.json')\n * }\n */\nexport function fetchUrls(config?: FetchConfig & Partial<{ limit: number | null }>): LoaderPlugin {\n  // If there is a limit specified we limit the number of concurrent calls\n  const limiter = config?.limit ? createLimiter(config.limit) : <T>(fn: () => Promise<T>) => fn()\n\n  return {\n    type: 'loader',\n    validate: isRemoteUrl,\n    exec: (value) => fetchUrl(value, limiter, config),\n  }\n}\n"],
  "mappings": "AAAA,SAAS,iBAAiB;AAC1B,SAAS,qBAAqB;AAE9B,SAAS,mBAAmB;AAW5B,MAAM,UAAU,CAAC,QAA+B;AAC9C,MAAI;AACF,WAAO,IAAI,IAAI,GAAG,EAAE;AAAA,EACtB,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAgBA,eAAsB,SACpB,KACA,SACA,QACwB;AACxB,MAAI;AACF,UAAM,OAAO,QAAQ,GAAG;AAGxB,UAAM,UAAU,QAAQ,SAAS,KAAK,CAAC,MAAM,EAAE,QAAQ,KAAK,CAAC,MAAM,MAAM,IAAI,MAAM,MAAS,GAAG;AAE/F,UAAM,OAAO,QAAQ,SAAS;AAE9B,UAAM,SAAS,MAAM;AAAA,MAAQ,MAC3B,KAAK,KAAK;AAAA,QACR;AAAA,MACF,CAAC;AAAA,IACH;AAEA,QAAI,OAAO,IAAI;AACb,YAAM,OAAO,MAAM,OAAO,KAAK;AAE/B,aAAO;AAAA,QACL,IAAI;AAAA,QACJ,MAAM,UAAU,IAAI;AAAA,MACtB;AAAA,IACF;AAEA,WAAO;AAAA,MACL,IAAI;AAAA,IACN;AAAA,EACF,QAAQ;AACN,WAAO;AAAA,MACL,IAAI;AAAA,IACN;AAAA,EACF;AACF;AAaO,SAAS,UAAU,QAAwE;AAEhG,QAAM,UAAU,QAAQ,QAAQ,cAAc,OAAO,KAAK,IAAI,CAAI,OAAyB,GAAG;AAE9F,SAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,IACV,MAAM,CAAC,UAAU,SAAS,OAAO,SAAS,MAAM;AAAA,EAClD;AACF;",
  "names": []
}
