{
  "version": 3,
  "sources": ["../../src/bundle/value-generator.ts"],
  "sourcesContent": ["/**\n * Generates a short SHA-1 hash from a string value.\n * This function is used to create unique identifiers for external references\n * while keeping the hash length manageable. It uses the Web Crypto API to\n * generate a SHA-1 hash and returns the first 7 characters of the hex string.\n * If the hash would be all numbers, it ensures at least one letter is included.\n *\n * @param value - The string to hash\n * @returns A 7-character hexadecimal hash with at least one letter\n * @example\n * // Returns \"2ae91d7\"\n * await getHash(\"https://example.com/schema.json\")\n */\nexport async function getHash(value: string) {\n  // Convert string to ArrayBuffer\n  const encoder = new TextEncoder()\n  const data = encoder.encode(value)\n\n  // Hash the data\n  const hashBuffer = await crypto.subtle.digest('SHA-1', data)\n\n  // Convert buffer to hex string\n  const hashArray = Array.from(new Uint8Array(hashBuffer))\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')\n\n  // Return first 7 characters of the hash, ensuring at least one letter\n  const hash = hashHex.substring(0, 7)\n  return hash.match(/^\\d+$/) ? 'a' + hash.substring(1) : hash\n}\n\n/**\n * Generates a unique compressed value for a string, handling collisions by recursively compressing\n * until a unique value is found. This is used to create unique identifiers for external\n * references in the bundled OpenAPI document.\n *\n * @param compress - Function that generates a compressed value from a string\n * @param value - The original string value to compress\n * @param compressedToValue - Object mapping compressed values to their original values\n * @param prevCompressedValue - Optional previous compressed value to use as input for generating a new value\n * @param depth - Current recursion depth to prevent infinite loops\n * @returns A unique compressed value that doesn't conflict with existing values\n *\n * @example\n * const valueMap = {}\n * // First call generates compressed value for \"example.com/schema.json\"\n * const value1 = await generateUniqueValue(compress, \"example.com/schema.json\", valueMap)\n * // Returns something like \"2ae91d7\"\n *\n * // Second call with same value returns same compressed value\n * const value2 = await generateUniqueValue(compress, \"example.com/schema.json\", valueMap)\n * // Returns same value as value1\n *\n * // Call with different value generates new unique compressed value\n * const value3 = await generateUniqueValue(compress, \"example.com/other.json\", valueMap)\n * // Returns different value like \"3bf82e9\"\n */\nexport async function generateUniqueValue(\n  compress: (value: string) => Promise<string> | string,\n  value: string,\n  compressedToValue: Record<string, string>,\n  prevCompressedValue?: string,\n  depth = 0,\n) {\n  // Prevent infinite recursion by limiting depth\n  const MAX_DEPTH = 100\n\n  if (depth >= MAX_DEPTH) {\n    throw 'Can not generate unique compressed values'\n  }\n\n  // Compress the value, using previous compressed value if provided\n  const compressedValue = await compress(prevCompressedValue ?? value)\n\n  // Handle collision by recursively trying with compressed value as input\n  if (compressedToValue[compressedValue] !== undefined && compressedToValue[compressedValue] !== value) {\n    return generateUniqueValue(compress, value, compressedToValue, compressedValue, depth + 1)\n  }\n\n  // Store mapping and return unique compressed value\n  compressedToValue[compressedValue] = value\n  return compressedValue\n}\n\n/**\n * Factory function that creates a value generator with caching capabilities.\n * The generator maintains a bidirectional mapping between original values and their compressed forms.\n *\n * @param compress - Function that generates a compressed value from a string\n * @param compressedToValue - Initial mapping of compressed values to their original values\n * @returns An object with a generate method that produces unique compressed values\n *\n * @example\n * const compress = (value) => value.substring(0, 6) // Simple compression example\n * const initialMap = { 'abc123': 'example.com/schema.json' }\n * const generator = uniqueValueGeneratorFactory(compress, initialMap)\n *\n * // Generate compressed value for new string\n * const compressed = await generator.generate('example.com/other.json')\n * // Returns something like 'example'\n *\n * // Generate compressed value for existing string\n * const cached = await generator.generate('example.com/schema.json')\n * // Returns 'abc123' from cache\n */\nexport const uniqueValueGeneratorFactory = (\n  compress: (value: string) => Promise<string> | string,\n  compressedToValue: Record<string, string>,\n) => {\n  // Create a reverse mapping from original values to their compressed forms\n  const valueToCompressed = Object.fromEntries(Object.entries(compressedToValue).map(([key, value]) => [value, key]))\n\n  return {\n    /**\n     * Generates a unique compressed value for the given input string.\n     * First checks if a compressed value already exists in the cache.\n     * If not, generates a new unique compressed value and stores it in the cache.\n     *\n     * @param value - The original string value to compress\n     * @returns A Promise that resolves to the compressed string value\n     *\n     * @example\n     * const generator = uniqueValueGeneratorFactory(compress, {})\n     * const compressed = await generator.generate('example.com/schema.json')\n     * // Returns a unique compressed value like 'example'\n     */\n    generate: async (value: string) => {\n      // Check if we already have a compressed value for this input\n      const cache = valueToCompressed[value]\n      if (cache) {\n        return cache\n      }\n\n      // Generate a new unique compressed value\n      const generatedValue = await generateUniqueValue(compress, value, compressedToValue)\n\n      // Ensure the generated string contains at least one non-numeric character\n      // This prevents the `setValueAtPath` function from interpreting the value as an array index\n      // by forcing it to be treated as an object property name\n      const compressedValue = generatedValue.match(/^\\d+$/) ? `a${generatedValue}` : generatedValue\n\n      // Store the new mapping in our cache\n      valueToCompressed[value] = compressedValue\n\n      return compressedValue\n    },\n  }\n}\n"],
  "mappings": "AAaA,eAAsB,QAAQ,OAAe;AAE3C,QAAM,UAAU,IAAI,YAAY;AAChC,QAAM,OAAO,QAAQ,OAAO,KAAK;AAGjC,QAAM,aAAa,MAAM,OAAO,OAAO,OAAO,SAAS,IAAI;AAG3D,QAAM,YAAY,MAAM,KAAK,IAAI,WAAW,UAAU,CAAC;AACvD,QAAM,UAAU,UAAU,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAG7E,QAAM,OAAO,QAAQ,UAAU,GAAG,CAAC;AACnC,SAAO,KAAK,MAAM,OAAO,IAAI,MAAM,KAAK,UAAU,CAAC,IAAI;AACzD;AA4BA,eAAsB,oBACpB,UACA,OACA,mBACA,qBACA,QAAQ,GACR;AAEA,QAAM,YAAY;AAElB,MAAI,SAAS,WAAW;AACtB,UAAM;AAAA,EACR;AAGA,QAAM,kBAAkB,MAAM,SAAS,uBAAuB,KAAK;AAGnE,MAAI,kBAAkB,eAAe,MAAM,UAAa,kBAAkB,eAAe,MAAM,OAAO;AACpG,WAAO,oBAAoB,UAAU,OAAO,mBAAmB,iBAAiB,QAAQ,CAAC;AAAA,EAC3F;AAGA,oBAAkB,eAAe,IAAI;AACrC,SAAO;AACT;AAuBO,MAAM,8BAA8B,CACzC,UACA,sBACG;AAEH,QAAM,oBAAoB,OAAO,YAAY,OAAO,QAAQ,iBAAiB,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,OAAO,GAAG,CAAC,CAAC;AAElH,SAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAcL,UAAU,OAAO,UAAkB;AAEjC,YAAM,QAAQ,kBAAkB,KAAK;AACrC,UAAI,OAAO;AACT,eAAO;AAAA,MACT;AAGA,YAAM,iBAAiB,MAAM,oBAAoB,UAAU,OAAO,iBAAiB;AAKnF,YAAM,kBAAkB,eAAe,MAAM,OAAO,IAAI,IAAI,cAAc,KAAK;AAG/E,wBAAkB,KAAK,IAAI;AAE3B,aAAO;AAAA,IACT;AAAA,EACF;AACF;",
  "names": []
}
