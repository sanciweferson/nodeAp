import { isLocalRef } from "../bundle/bundle.js";
import { getSegmentsFromPath } from "../utils/get-segments-from-path.js";
import { isObject } from "../utils/is-object.js";
import { getValueByPath, parseJsonPointer } from "../utils/json-path-utils.js";
const isMagicProxy = Symbol("isMagicProxy");
const magicProxyTarget = Symbol("magicProxyTarget");
const REF_VALUE = "$ref-value";
const REF_KEY = "$ref";
const createMagicProxy = (target, root = target, cache = /* @__PURE__ */ new Map()) => {
  if (!isObject(target) && !Array.isArray(target)) {
    return target;
  }
  const handler = {
    /**
     * Proxy "get" trap for magic proxy.
     * - If accessing the special isMagicProxy symbol, return true to identify proxy.
     * - If accessing the magicProxyTarget symbol, return the original target object.
     * - If accessing "$ref-value" and the object has a local $ref, resolve and return the referenced value as a new magic proxy.
     * - For all other properties, recursively wrap the returned value in a magic proxy (if applicable).
     */
    get(target2, prop, receiver) {
      if (prop === isMagicProxy) {
        return true;
      }
      if (prop === magicProxyTarget) {
        return target2;
      }
      const ref = Reflect.get(target2, REF_KEY, receiver);
      if (prop === REF_VALUE && typeof ref === "string" && isLocalRef(ref)) {
        if (cache.has(ref)) {
          return cache.get(ref);
        }
        const resolvedValue = getValueByPath(root, parseJsonPointer(ref));
        const proxiedValue = createMagicProxy(resolvedValue, root, cache);
        cache.set(ref, proxiedValue);
        return proxiedValue;
      }
      const value = Reflect.get(target2, prop, receiver);
      return createMagicProxy(value, root, cache);
    },
    /**
     * Proxy "set" trap for magic proxy.
     * Allows setting properties on the proxied object.
     * This will update the underlying target object.
     */
    set(target2, prop, newValue, receiver) {
      const ref = Reflect.get(target2, REF_KEY, receiver);
      if (prop === REF_VALUE && typeof ref === "string" && isLocalRef(ref)) {
        const segments = getSegmentsFromPath(ref);
        if (segments.length === 0) {
          return false;
        }
        const parentNode = getValueByPath(root, segments.slice(0, -1));
        if (!parentNode || !isObject(parentNode) && !Array.isArray(parentNode)) {
          return false;
        }
        parentNode[segments.at(-1)] = newValue;
        return true;
      }
      return Reflect.set(target2, prop, newValue, receiver);
    },
    /**
     * Proxy "deleteProperty" trap for magic proxy.
     * Allows deleting properties from the proxied object.
     * This will update the underlying target object.
     */
    deleteProperty(target2, prop) {
      return Reflect.deleteProperty(target2, prop);
    },
    /**
     * Proxy "has" trap for magic proxy.
     * - Pretend that "$ref-value" exists if "$ref" exists on the target.
     *   This allows expressions like `"$ref-value" in obj` to return true for objects with a $ref,
     *   even though "$ref-value" is a virtual property provided by the proxy.
     * - For all other properties, defer to the default Reflect.has behavior.
     */
    has(target2, prop) {
      if (prop === REF_VALUE && REF_KEY in target2) {
        return true;
      }
      return Reflect.has(target2, prop);
    },
    /**
     * Proxy "ownKeys" trap for magic proxy.
     * - Returns the list of own property keys for the proxied object.
     * - If the object has a "$ref" property, ensures that "$ref-value" is also included in the keys,
     *   even though "$ref-value" is a virtual property provided by the proxy.
     *   This allows Object.keys, Reflect.ownKeys, etc. to include "$ref-value" for objects with $ref.
     */
    ownKeys(target2) {
      const keys = Reflect.ownKeys(target2);
      if (REF_KEY in target2 && !keys.includes(REF_VALUE)) {
        keys.push(REF_VALUE);
      }
      return keys;
    },
    /**
     * Proxy "getOwnPropertyDescriptor" trap for magic proxy.
     * - For the virtual "$ref-value" property, returns a descriptor that makes it appear as a regular property.
     * - For all other properties, delegates to the default Reflect.getOwnPropertyDescriptor behavior.
     * - This ensures that Object.getOwnPropertyDescriptor and similar methods work correctly with the virtual property.
     */
    getOwnPropertyDescriptor(target2, prop) {
      const ref = Reflect.get(target2, REF_KEY);
      if (prop === REF_VALUE && typeof ref === "string") {
        return {
          configurable: true,
          enumerable: true,
          value: void 0,
          writable: false
        };
      }
      return Reflect.getOwnPropertyDescriptor(target2, prop);
    }
  };
  return new Proxy(target, handler);
};
function getRaw(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (obj[isMagicProxy]) {
    return obj[magicProxyTarget];
  }
  return obj;
}
export {
  createMagicProxy,
  getRaw
};
//# sourceMappingURL=proxy.js.map
